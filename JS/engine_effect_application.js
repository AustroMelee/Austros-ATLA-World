'use strict';

import { EFFECT_TYPES, MECHANIC_DEFINITIONS } from './data_mechanics_definitions.js';
import { effectHandlers, createEffectContext } from './effect_handlers/index.js';

/**
 * Applies a single game effect to a character or the battle state.
 * This is a centralized function for all effect application, driven by data and using the Strategy Pattern.
 * Now uses the modular effect handlers system with unified context approach.
 * @param {object} effect - The effect object, containing type and parameters (e.g., { type: 'damage', value: 20 }).
 * @param {object} actor - The character initiating the effect (can be null for environmental effects).
 * @param {object} target - The character receiving the effect (can be null for global effects).
 * @param {object} battleState - The current battle state object.
 * @param {Array} battleEventLog - The log to push narrative events to (unused, kept for compatibility).
 * @returns {object} An object indicating if the effect was successfully applied and any relevant messages.
 */
export function applyEffect(effect, actor, target, battleState, battleEventLog) {
    if (!effect || !effect.type) {
        console.warn("Attempted to apply an invalid effect:", effect);
        return { success: false, message: "Invalid effect.", events: [] };
    }

    const definition = MECHANIC_DEFINITIONS[effect.type];
    if (!definition) {
        console.warn(`No definition found for effect type: ${effect.type}`);
        return { success: false, message: `Unknown effect type: ${effect.type}`, events: [] };
    }

    // Look up the handler for this effect type using Map.get()
    const handler = effectHandlers.get(effect.type);
    if (!handler) {
        console.warn(`No handler found for effect type: ${effect.type}`);
        return { success: false, message: `No handler for effect type: ${effect.type}`, events: [] };
    }

    let primaryTarget = null; // Reference to the actual object being modified
    let generatedEvents = []; // Array to collect events generated by this function

    // Determine the primary target based on the definition
    switch (definition.targets[0]) { // Assuming primary target is always the first in the list
        case 'target': primaryTarget = target; break;
        case 'self': primaryTarget = actor; break;
        case 'environment': primaryTarget = battleState.environmentState; break;
        case 'global': primaryTarget = battleState; break;
    }

    if (!primaryTarget && definition.targets[0] !== 'global') {
        console.warn(`Effect type ${effect.type} requires a target but none was provided.`);
        return { success: false, message: `Missing target for ${effect.type}.`, events: generatedEvents };
    }

    // Capture old values before applying effect for status change logging
    const oldValues = {
        oldHp: primaryTarget?.hp,
        oldEnergy: primaryTarget?.energy,
        oldMentalState: primaryTarget?.mentalState,
        oldMomentum: primaryTarget?.momentum,
        oldStunDuration: primaryTarget?.stunDuration
    };

    // Validate required parameters
    for (const paramName in definition.params) {
        if (definition.params[paramName].required && effect[paramName] === undefined) {
            console.error(`Missing required parameter '${paramName}' for effect type ${effect.type}.`);
            return { success: false, message: `Missing parameter ${paramName}.`, events: generatedEvents };
        }
    }

    // Create unified context for the handler
    const context = createEffectContext(effect, actor, target, primaryTarget, battleState, oldValues, generatedEvents);

    // Apply the effect using the appropriate handler (Strategy Pattern with unified context)
    try {
        const result = handler(context);
        return { 
            success: result.success, 
            message: result.message, 
            events: generatedEvents,
            subResults: result.subResults // For composite effects
        };
    } catch (error) {
        console.error(`Error applying effect ${effect.type}:`, error);
        return { 
            success: false, 
            message: `Error applying effect: ${error.message}`, 
            events: generatedEvents 
        };
    }
} 