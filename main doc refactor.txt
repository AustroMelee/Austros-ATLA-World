Of course. Here is the complete, refactored set of documentation, broken down into logical, enterprise-grade files. All information from the original document has been preserved and organized.

Each file is separated by a horizontal rule (---) and a clear file path header.

File: README.md
Avatar Battle Arena

This repository contains the source code for the Avatar Battle Arena, a next-gen, turn-based battle simulator.

For a complete overview of the system's architecture, start with the main System Architecture Document.

System Health Dashboard
Metric	Status
CI Pipeline	
![alt text](https://github.com/user/repo/actions/workflows/ci.yml/badge.svg)

Test Coverage	
![alt text](https://codecov.io/gh/user/repo/branch/main/graph/badge.svg)

Code Quality	
![alt text](https://www.codefactor.io/repository/github/user/repo/badge)

Bundle Size	
![alt text](https://vercel-badge-gamma.vercel.app/?target=...&stat=size)

Dependencies	
![alt text](https://badges.depfu.com/badges/...)

Type Coverage	
![alt text](https://img.shields.io/badge/Type%20Coverage-99.8%25-brightgreen)
File: docs/SYSTEM_ARCHITECTURE.MD
System Architecture: Avatar Battle Arena

This document provides a high-level overview of the Avatar Battle Arena system. It serves as the primary entry point for understanding its core design, principles, and how to navigate the more detailed documentation.

Quick Links

Project README

System Architecture (This document)

Engine Deep Dive

UI & Frontend Guide

Developer & Contribution Guide

Core System Policies

The Logging System

Documentation Policy

Architecture Decision Records (ADRs)

Changelog

Glossary of Terms

Cursor Effectiveness Checklist

Main App Entry (App.tsx)

React Entry Point (main.tsx)

Docs Refresh Script Instructions

Architectural Tenets

Correctness Over Performance: The simulation must be narratively and mechanically correct first. Optimize only after correctness is proven.

Prevent Stalemates At All Costs: Every mechanic must ultimately drive the battle towards a conclusion. Infinite loops are the cardinal sin. This is enforced by an engine-level forced ending and phase-based escalation/desperation logic.

The AI is a Character, Not a Bot: AI decisions must be explainable through personality and context. Black-box logic is forbidden. All AI is now contract-bound and phase-driven, with strict move pool enforcement in escalation/desperation.

Readability is a Feature: Clear, SRP-compliant code is more maintainable than clever, dense code. If it requires a 10-minute explanation, refactor it.

Documentation is Not an Afterthought: Documentation is part of the definition of done. If it's not documented here, the feature isn't finished.

Log Hygiene and Type Safety: All logs are created via robust helpers (logTechnical, logStory), never null, and strictly typed. All escalation/desperation/AI/phase logic is type-safe and documented.

System Overview

The Avatar Battle Arena is a next-gen, turn-based battle simulator built on several key architectural pillars:

Strict TypeScript: any is forbidden. All types are explicit for maximum safety and developer clarity. All escalation/desperation/AI/phase logic is now fully type-safe.

Service-Oriented Modularity (SRP): The Single Responsibility Principle is applied at every level. Services are focused, testable, and independent.

Phase-Based Combat Loop: The battle engine processes turns through a clean, predictable pipeline (e.g., validateBattleEndPhase → escalationPhase → tacticalMovePhase), making the combat flow easy to trace and extend. Escalation and desperation are now strictly phase-based, with no legacy flag checks.

Deadlock-Proof AI: The AI features robust anti-stalemate logic, using risk tolerance, tactical counters, and desperation gambles to actively break deadlocks. AI move selection is now contract-bound and phase-driven, with strict move pool enforcement in escalation/desperation.

Consequence-Driven Escalation: The battle arc state machine controls fight pacing. Stalemates trigger escalating consequences, culminating in a guaranteed, decisive Sudden Death phase. All escalation/desperation logic is robust, type-safe, and future-proof.

Plug-and-Play Content: All finisher logic, moves, characters, and narrative are data-driven. Adding or changing content is a pure data/registry operation—no engine code changes are required.

Log Hygiene: All logs are created via robust helpers, never null, and strictly typed. No log entry is ever null or malformed.

High-Level Architecture Diagram
Generated mermaid
graph TD
    UI["UI Components"] --> |"User Actions, State"| BattleEngine["Battle Engine"]
    BattleEngine --> |"Battle State, Events"| AI["AI & Decision Logic"]
    BattleEngine --> |"Battle State, Events"| Narrative["Narrative System"]
    BattleEngine --> |"State, Data"| Data["Data & Types"]
    AI --> |"Move Choices, Analysis"| BattleEngine
    Narrative --> |"Narrative Output"| UI
    Data --> |"Types, Static Data"| BattleEngine
    Data --> |"Types, Static Data"| AI
    Data --> |"Types, Static Data"| Narrative
    Utilities["Utilities & Hooks"] --> |"Shared Logic"| UI
    Utilities --> |"Shared Logic"| BattleEngine
    Utilities --> |"Shared Logic"| AI
    Utilities --> |"Shared Logic"| Narrative

Battle Arc State Machine
Generated mermaid
stateDiagram-v2
    [*] --> Idle
    Idle --> Escalation: Stalemate detected
    Escalation --> Climax: Escalation limit reached
    Climax --> Sudden_Death: Climax fails to resolve
    Sudden_Death --> End: Finisher clash
    Escalation --> End
    Climax --> End
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Mermaid
IGNORE_WHEN_COPYING_END
File: docs/ENGINE_DEEP_DIVE.md
Engine Deep Dive

This document provides a detailed view of the core battle engine's internal logic, data flows, and key implementation points. It is intended for developers working directly on the simulation and AI systems.

System Diagrams & Visualizations
Turn Processing Flow (Activity Diagram)
Generated mermaid
graph TD
    A[Start Turn] --> B(Update Real-Time Analytics);
    B --> C{End-Game Check?<br/>(KO / Decisive Win / Sudden Death Trigger)};
    C -- Yes --> D[End Battle];
    C -- No --> E{Escalation Check?<br/>(Stalemate / Repetition)};
    E -- Escalate --> F[Set Escalation/Risk Flags & Enter Escalation Phase];
    F --> G{Tactical Move Phase};
    E -- No --> G;
    G -- Sudden Death? --> H[Force Finisher Move!];
    G -- Escalation? --> I[Force Aggressive Move / Charge Power];
    G -- Desperation? --> J[Only Desperation/Finisher Moves Allowed];
    G -- Normal --> K[Execute AI-Chosen Tactical Move];
    H --> L{Resolve Move & Apply Damage};
    I --> L;
    J --> L;
    K --> L;
    L --> M{End-of-Turn Effects<br/>(Status Ticks / Effect Fusion)};
    M -- KO? --> D;
    M -- No --> N[Switch Active Player & Increment Turn];
    N --> A;

    style D fill:#c00,stroke:#333,stroke-width:2px,color:#fff;
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Mermaid
IGNORE_WHEN_COPYING_END
AI Decision Pipeline (Flowchart)
Generated mermaid
graph TD
    subgraph AI Decision
        A[Start AI Turn] --> B(Calculate Risk & Stalemate Counters);
        B --> C{Get Available Moves<br/>(Hard-filtered by Chi, Cooldowns, Uses & Collateral)};
        C -- No Moves Available --> D[Choose "Gather Power" / Skip Turn];
        C -- Moves Available --> E{Determine Tactical Priority<br/>(Attack, Defend, Pierce, Gamble...)};
        E --> F[Score Available Moves Based on Priority];
        F --> G[Adjust Scores by Character Identity];
        G --> H[Select Best Move];
        H --> I[End AI Turn: Execute Move];
        D --> I;
    end
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Mermaid
IGNORE_WHEN_COPYING_END
Turn Processing Call Stack (Sequence Diagram)
Generated mermaid
sequenceDiagram
    participant UI
    participant useBattleSimulator
    participant battleSimulator.service
    participant processTurn
    participant tacticalPhase

    UI->>useBattleSimulator: runSimulation()
    useBattleSimulator->>battleSimulator.service: run()
    loop Until Battle End
        battleSimulator.service->>processTurn: execute(state)
        processTurn->>tacticalPhase: execute(state)
        tacticalPhase-->>processTurn: updatedState
        processTurn-->>battleSimulator.service: updatedState
    end
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Mermaid
IGNORE_WHEN_COPYING_END
Key Logic Locator

This table maps core gameplay logic to its exact location.

Core Logic	File & Function Location
Damage Calculation	tacticalPhase.service.ts → applyMoveEffects()
Stalemate Detection	arc.service.ts → checkForStalemate()
AI Move Scoring	enhancedMoveScoring.ts → scoreMove()
Cooldown Ticks	useBattleSimulator.controller.ts → endTurn() loop
Engine-Level Forced Ending	escalationPhase.service.ts → handleEscalationPhase()
Escalation/Desperation Phase Logic	escalationDetection.service.ts, escalationApplication.service.ts, desperationSystem.service.ts, escalationPhase.service.ts
Contract-Bound AI Move Selection	advancedAIController.ts → selectAIMove()
Log Hygiene & Safety	mechanicLogUtils.ts → logTechnical(), logStory()
Forced Ending/Narrative Guarantee	advancedAIController.ts, moveSelection.ts, desperationSystem.service.ts, finisherSystem.service.ts, escalationPhase.service.ts, processTurn.ts, mechanicLogUtils.ts, UnifiedBattleLog.tsx, battle-log-pipeline.test.ts

Note: This table is manually curated. If you refactor core logic, please update this table.

Dynamically Used Modules
File	Consuming System	Usage Mechanism
src/features/battle-simulation/services/battle-simulation/services/battle/desperationSystem.service.ts	BattleEngine	Dynamic registry lookup
src/features/battle-simulation/services/battle/arc.service.ts	BattleEngine	Dynamic registry lookup
src/features/battle-simulation/services/battle/criticalSystem.service.ts	BattleEngine	Dynamic registry lookup
src/features/battle-simulation/services/battle/desperationMoveCreation.service.ts	BattleEngine	Dynamic registry lookup
src/features/battle-simulation/services/battle/desperationMoves.ts	BattleEngine	Dynamic registry lookup
src/features/battle-simulation/services/battle/disruptionWindow.service.ts	BattleEngine	Dynamic registry lookup
src/features/battle-simulation/services/battle/effectFusion.service.ts	BattleEngine	Dynamic registry lookup
src/features/battle-simulation/services/battle/endPhase.service.ts	BattleEngine	Dynamic registry lookup
src/features/battle-simulation/services/battle/escalationPhase.service.ts	BattleEngine	Dynamic registry lookup
src/features/battle-simulation/services/battle/logIdGenerator.service.ts	BattleEngine	Dynamic registry lookup
src/features/battle-simulation/services/ai/advancedAIController.ts	AI Engine	Dynamic registry lookup
src/features/battle-simulation/services/ai/battleAwareness.ts	AI Engine	Dynamic registry lookup
src/features/battle-simulation/services/ai/behaviorTreeEngine.ts	AI Engine	Dynamic registry lookup
src/features/battle-simulation/services/ai/chooseAbility.ts	AI Engine	Dynamic registry lookup
src/features/battle-simulation/services/ai/narrative.ts	AI Engine	Dynamic registry lookup
src/features/battle-simulation/services/ai/tacticalAI.service.ts	AI Engine	Dynamic registry lookup
src/features/battle-simulation/services/ai/tacticalNarrative.ts	AI Engine	Dynamic registry lookup
src/features/battle-simulation/services/narrative/enhancedNarrativeSystem.ts	Narrative Engine	Dynamic registry lookup
src/features/battle-simulation/services/narrative/enhancedRepetitionManager.ts	Narrative Engine	Dynamic registry lookup
src/features/battle-simulation/services/narrative/enhancedStateManager.ts	Narrative Engine	Dynamic registry lookup
src/features/battle-simulation/services/narrative/enhancedStateNarratives.ts	Narrative Engine	Dynamic registry lookup
src/features/battle-simulation/services/narrative/enhancedTemplateGenerator.ts	Narrative Engine	Dynamic registry lookup
src/features/battle-simulation/services/narrative/index.ts	Narrative Engine	Dynamic registry lookup
src/features/battle-simulation/services/utils/mechanicLogUtils.ts	BattleEngine/utilities	Dynamic registry lookup
src/features/battle-simulation/services/utils/moveUtils.ts	BattleEngine/utilities	Dynamic registry lookup
src/features/battle-simulation/hooks/useNarrativeLine.ts	Narrative Engine/UI	Dynamic registry lookup or React hook
src/features/battle-simulation/services/narrative/utils/antiRepetition.utility.ts	Narrative Engine	Dynamic registry lookup
src/features/battle-simulation/services/narrative/utils/fallbackGenerator.utility.ts	Narrative Engine	Dynamic registry lookup
src/features/battle-simulation/services/narrative/utils/narrativeKey.utility.ts	Narrative Engine	Dynamic registry lookup
src/features/battle-simulation/services/narrative/utils/pronoun.utility.ts	Narrative Engine	Dynamic registry lookup
src/features/battle-simulation/services/battleSimulator.service.ts	BattleEngine	Dynamic registry lookup
src/features/battle-simulation/services/battle/reportGenerator.service.ts	BattleEngine	Dynamic registry lookup
src/features/battle-simulation/services/battle/finisherSystem.service.ts	BattleEngine	Dynamic registry lookup
src/features/battle-simulation/services/battle/genericMove.service.ts	BattleEngine	Dynamic registry lookup
src/features/battle-simulation/services/battle/moveRegistry.service.ts	BattleEngine	Dynamic registry lookup
src/features/battle-simulation/services/battle/moveRouter.service.ts	BattleEngine	Dynamic registry lookup
src/features/battle-simulation/services/battle/phases/desperationPhase.service.ts	BattleEngine	Dynamic registry lookup
File: docs/UI_GUIDE.md
UI & Frontend Guide

This guide covers the architecture, conventions, and implementation details for the React-based user interface.

UI DOM Architecture & Insights
High-Level React/DOM Tree
Generated mermaid
graph TD
    Root["#root (React root)"]
    App["App.tsx (_appContainer_1rx4b_1)"]
    Header["Header (_header_1rx4b_37)"]
    Main["Main Content (_mainContent_1rx4b_143)"]
    BattleScene["BattleScene (_container_czwm9_1)"]
    VersusGrid["VersusGrid (_versusGrid_dmjnw_1)"]
    Player1["PlayerCardHorizontal (Player 1)"]
    Player2["PlayerCardHorizontal (Player 2)"]
    AbilityPanel["AbilityPanel"]
    UnifiedBattleLog["UnifiedBattleLog (_unifiedBattleLog_1q2w3_1)"]
    ErrorBoundary["ErrorBoundary"]
    Suspense["Suspense (LoadingSpinner)"]

    Root --> App
    App --> ErrorBoundary
    ErrorBoundary --> Suspense
    Suspense --> Header
    Suspense --> Main
    Main --> BattleScene
    BattleScene --> VersusGrid
    VersusGrid --> Player1
    VersusGrid --> Player2
    BattleScene --> AbilityPanel
    BattleScene --> UnifiedBattleLog
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Mermaid
IGNORE_WHEN_COPYING_END
CSS, Theming, and Accessibility

CSS Modules: All UI components use locally-scoped CSS modules to prevent class name collisions.

CSS Variables: Theming is controlled by CSS variables in styles/variables.css for colors, spacing, and fonts.

Layout: Flexbox and grid are used for main layouts. All spacing uses explicit gap or padding values from variables.

Accessibility: Root-level UI is wrapped in ErrorBoundary and Suspense with accessible fallbacks. All interactive elements have ARIA labels and are keyboard accessible.

Defensive UI: Log rendering is guarded against undefined/null data, with warnings logged and placeholders shown for malformed data.

Key CSS Variables
Variable	Value	Usage Context
--font-heading	'Poppins', sans-serif	Headings, titles
--font-mono	'JetBrains Mono', monospace	Code, technical log
--background-color-dark	#0F172A	Main app background
--text-color-primary	#F8FAFC	Main text color
--border-color-soft	#475569	Soft borders, dividers
--player-1-color	#3B82F6	Player 1 highlights, borders
--player-2-color	#EF4444	Player 2 highlights, borders
--highlight-color	#F59E0B	Highlights, buttons, accents
--spacing-medium	16px	Medium gaps, padding
Battle Log View Modes & Dropdown

Log View Dropdown: The battle log UI now features a persistent dropdown at the top, allowing instant toggling between multiple log view modes.

Modes:

[DEV] Grouped by Turn – Full battle transcript: Shows all log entries grouped and ordered by turn, with headers for each turn. For developers and testers.

[DEV] Latest Turn Only – Just current turn: Shows only the most recent turn's entries. For rapid debugging and step-by-step analysis.

[DEV] All Entries (Raw) – Unfiltered log: Shows every log entry in order, with no grouping. For log system debugging.

[PUBLIC] Story View – For players/spectators: (Currently same as grouped, but intended for user-facing release. Only this mode is shown in production.)

Dropdown Placement: The dropdown is always rendered at the very top of the log area, before any log content, and is never hidden or delayed.

Educational Labels: Each dropdown option includes a one-line summary for clarity. [DEV] modes are only visible in development; [PUBLIC] is the only option in production.

Rationale: This design ensures maximum clarity for both developers and users, prevents UI drift, and makes the tool self-explanatory.

Log UI Update Best Practices & File Map

Log pipeline and UI are now robust, type-safe, and future-proof.

Renderer: UnifiedBattleLog.tsx uses an exhaustive switch to render only true dialogue as bubbles, with unknown types rendered as neutral gray.

Unit Test: UnifiedBattleLog.test.tsx covers all core log types and ensures exhaustive rendering.

Lint Rule: Custom ESLint plugin prevents stray imports of DialogueLogEntry outside the canonical context.

Type Helper: assertNever enforces compile-time exhaustiveness for log type switches.

Log Creation: All logs are created via robust helpers (logTechnical, logStory, logDialogue, logSystem), never null, and strictly typed. All tactical subtypes are mapped to canonical types at the source. Duplicate log entries are prevented with a hash/set utility.

Checklist for Log UI Updates:

Update log text in helpers/templates as needed

Update styles in log entry components or CSS modules

Update dropdown options/labels and logic

Update/add log action buttons

Update SYSTEM ARCHITECTURE.MD and ALL_FILES_INDEX.md to reflect changes

Run and visually verify all log modes (DEV and PUBLIC)

File Map for Log UI:

Log text: mechanicLogUtils.ts, narrative pools/templates

Log styles: DialogueLogEntry.tsx, NarrativeLogEntry.tsx, TechnicalLogEntry.tsx, variables.css

Dropdown: UnifiedBattleLog.tsx, logViewModes.ts

Buttons: UnifiedBattleLog.tsx (or subcomponents)

Policy: All log UI changes must be reflected in this document and in ALL_FILES_INDEX.md to prevent drift.

File: CONTRIBUTING.md
Developer & Contribution Guide

This guide provides everything a developer needs to get started with the codebase, from initial setup to extending the system with new content and troubleshooting common issues.

Onboarding/Quick Start

Clone the repository:

Generated bash
git clone <your-repo-url>
cd avatar-battle-arena
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Bash
IGNORE_WHEN_COPYING_END

Install dependencies:

Generated bash
npm install
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Bash
IGNORE_WHEN_COPYING_END

Start the development server:

Generated bash
npm run dev
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Bash
IGNORE_WHEN_COPYING_END

The application will be available at http://localhost:3000.

Run code quality checks:

Generated bash
npm run lint:fix
npx tsc --noEmit
npx vitest run
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Bash
IGNORE_WHEN_COPYING_END

Lint, type, and test checks must be clean before you commit.

Workflow guidelines:

All new content (characters, moves, logs, UI changes) must follow plug-and-play and branding rules.

Run npm run docs:refresh to update documentation after structural changes.

Never commit without updating documentation if you change logic, structure, or key files.

Key files for reference:

docs/SYSTEM_ARCHITECTURE.MD: Full system overview, policies, and best practices.

docs/ALL_FILES_INDEX.md: Canonical file map, auto-generated.

Codebase Cookbooks: How to Extend the System

This section provides step-by-step instructions for adding new content. Following these guides ensures the system remains scalable and maintainable.

How to Add a New Character (e.g., Zuko)

Adding a new character is a data-only operation. You do not need to modify any core engine files.

Define Moves:

Open src/features/battle-simulation/data/moves.ts.

Add new Move objects for the character's abilities (e.g., zuko_fire_whip). Ensure each id is unique.

Define Character Data:

Open src/features/character-selection/data/characterData.ts.

Add a new Character object to the availableCharacters array.

In the abilities array, list the unique ids of the moves you defined in step 1.

Set the aiRulesetId and narrativeId to a unique key (e.g., 'zuko').

Create AI Rules:

Create src/features/battle-simulation/services/ai/rules/zukoRules.ts.

Define and export an array of AIRule objects for Zuko's behavior.

Register AI Rules:

Open src/features/battle-simulation/services/ai/rules/aiRuleRegistry.service.ts.

Import zukoAIRules and register it in the constructor: this.register('zuko', zukoAIRules);

Create Narrative Pool:

Create src/features/battle-simulation/services/narrative/pools/zuko.narrative.ts.

Define and export a CharacterNarrativePool object with Zuko's dialogue.

Register Narrative Pool:

Open src/features/battle-simulation/services/narrative/pools/narrativePoolRegistry.service.ts.

Import zukoNarrativePool and register it: this.register('zuko', zukoNarrativePool);

Add Assets:

Add character images (e.g., zuko.jpg) to the /public/assets/ directory.

How to Add a New Location

Add Location Data:

Open src/features/location-selection/data/locationData.ts.

Add a new Location object to the availableLocations array.

Add Asset:

Add the location image to /public/assets/.

How to Add a New Move

Define the Move:

Open src/features/battle-simulation/data/moves.ts.

Add a new Move object to the ALL_MOVES array.

Assign to Character(s):

Open src/features/character-selection/data/characterData.ts.

Add the new move's id to the abilities array of any character who should use it.

How to Ensure Dynamic Fighter Names in the Simulation UI (No Hardcoding)

Goal: The simulation UI must always display the actual character names (e.g., "Aang" and "Azula") instead of hardcoded labels like "Fighter 1" and "Fighter 2". This supports plug-and-play extensibility for any future characters.

Where Names Are Rendered

UnifiedBattleLog.tsx: The main battle log UI. Renders all log entries and passes participant names to log entry components.

DialogueLogEntry.tsx: Renders individual dialogue lines, displaying the actor prop as the speaker's name.

How Participants Are Passed

The simulation state (BattleState.participants) always contains the two current fighters as BattleCharacter objects, each with a name property.

The UnifiedBattleLog component receives a participants prop (an array of two BattleCharacters) and uses their .name fields for all log rendering.

All log and dialogue rendering (including SingleLogEntry, TurnGroup, and renderNarrativeTab in UnifiedBattleLog.tsx) must use these dynamic names, never hardcoded labels.

Contributor Checklist: Dynamic Fighter Name Display

Never hardcode participant labels (e.g., "Fighter 1", "Fighter 2") in any UI or log component.

Always use the .name property from the BattleCharacter objects in the simulation state.

When adding new log or dialogue UI, ensure the actor/speaker is set dynamically from the participant data.

When adding new characters, confirm their names are set in the registry and appear correctly in the UI.

Reference this section in PRs or code reviews when making changes to log or participant display logic.

Policy: All log and dialogue rendering must use the real character names from the simulation state. Hardcoded labels are forbidden.

Testing & Deployment

(This section is a placeholder for detailed strategies)

12.1. Testing Strategy: Includes unit, integration, and end-to-end tests.

12.2. CI/CD and Deployment: Automated pipeline for testing, building, and deploying.

Lint & Auto-fix

Run npm run lint:fix to apply ESLint auto-fixes. The CI workflow rejects commits with any remaining lint errors. This command is enforced in package.json scripts, developer docs, and CI configuration.

FAQ & Common Pitfalls

Q: Why do I get branded string/type errors?
A: All log and narrative strings must be wrapped with nes(...). Don’t assign plain strings to NonEmptyString fields.

Q: Why is CI or pre-commit rejecting my code?
A: You have lint, type, or doc sync errors. Run npm run lint:fix, npx tsc --noEmit, and npm run docs:refresh.

Q: Why aren’t my log/narrative changes showing in the UI?
A: You may not be using the correct log helpers, or you forgot to update the log pipeline/registry.

Q: What causes “actor property not allowed” errors?
A: Only dialogue log entries may have an actor property. Check log type and field usage.

Common mistakes to avoid:

Hardcoding participant names. Always use the .name field.

Editing generated files by hand. Use scripts (npm run docs:refresh) instead.

Not running pre-commit checks before pushing.

Troubleshooting Playbook

If you hit a branded string/type error:

Wrap the value with nes(...).

Never assign '' or allow empty strings to pass to log fields.

If CI fails or code won’t commit:

Run the following commands:

Generated bash
npm run lint:fix
npx tsc --noEmit
npm run docs:refresh
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Bash
IGNORE_WHEN_COPYING_END

Fix any issues that show up in the output.

If log changes don’t appear:

Make sure you updated the correct narrative pool or log registry.

Restart the dev server and hard-refresh the browser.

If you get “actor not allowed” or log pipeline errors:

Double-check log type and fields.

Only use actor with dialogue logs.

If you’re not sure what broke:

Check SYSTEM_ARCHITECTURE.MD, recent ADRs, and /docs/error-reports/.

Run the “canary” AI-vs-AI simulation test suite to force pipeline validation.

File: docs/POLICIES.md
Core System Policies

This document outlines the mandatory policies, rules, and best practices that govern the development of this system. Adherence to these policies is required for all contributions.

Core Policies
10.1. Plug-and-Play Compliance Policy (MANDATORY)

All new features, content, and mechanics must be implemented in a strictly plug-and-play fashion.

No hard-coded references to specific entities (characters, moves, etc.) are allowed in core logic.

All extensible entities must be registered via explicit registries and referenced by ID.

Adding new content must never require changes to core engine, AI, or narrative code.

Any PR or commit that violates this policy must be rejected or refactored before merge.

10.2. Logging Architecture Policy

All battle log entries are strictly separated by type.

All engine sub-phases must return log entries to be appended only in processTurn.

UI components must filter and render logs based on their type.

See the Logging System Guide for full details.

10.3. Test/Mock Data Policy

All test data should be isolated and clearly marked. Mock data should accurately reflect the shape of real data types.

10.4. Security, Privacy, and Dependency Management

Regularly audit dependencies for vulnerabilities.

No sensitive data should ever be stored in the codebase or logs.

Follow a clear versioning and change management process for all updates.

Technical Enforcement Policies
Log Pipeline & Type-Safety Best Practices (2025)

Contract-first changes: Any new log field/type change must ship with a red-green test and an ESLint rule. ADRs must include a “compile-time guarantees” section.

Single-source branding: All branded utility types (e.g., NonEmptyString) must live only in types/index.ts. No redeclaration in other modules. Enforced by eslint-plugin-import rule no-internal-redeclare.

Discriminated unions for logs: Dialogue logs (type: 'dialogue') must require an actor (fighter name); all other log types must not allow a fighter actor.

Runtime guards: All logs must be validated at runtime: no empty strings, every log must have a turn, and all fields must pass type assertions.

CI “canary” simulation: CI must run a long AI-vs-AI battle and fail on the first malformed log entry.

Pre-commit enforcement: lint-staged must run npm run lint -- --max-warnings=0 and vitest --run on all touched files. No PR may merge with lint or test failures.

Reference: See /docs/error-reports/Error Report - July 9th 2025.md for the full post-mortem and rationale.

Anti-Stalemate, Escalation, and Narrative Log Enforcement (2025-07)

All escalation, desperation, and forced ending code paths must strictly enforce move pool restrictions: AI cannot select basic or repetitive moves in escalation or desperation phases.

If no escalation/desperation/finisher move is available, the battle must end immediately with a forced ending (never a draw or endless loop).

Every escalation, desperation, and forced ending event must append at least one narrative or dialogue log to the main battleLog array (not just technical logs).

All log creation must use branded, type-safe helpers (logStory, logDialogue, logTechnical) and be appended to the main log array for UI rendering.

Test coverage must assert that every turn and every battle outcome includes at least one narrative or dialogue log.

Onboarding: Unused/Legacy File Policy

All orphaned/unused files are listed in UNUSED_FILES_REPORT.md, auto-generated by CI.

Every flagged file must have a rationale or @legacy tag in its header.

Do not use or resurrect files flagged as @legacy or listed in the report without consulting the project architect.

Before merging, confirm the checklist:

Not imported anywhere (static/dynamic analysis)

No runtime references or dynamic loading

Superseded file is live and covered by tests

Changelog/GitHub issue updated

Team notified

Lessons Learned
Branded String Hygiene & Log Actor Enforcement

A multi-batch, repo-wide effort in July 2025 enforced strict branded string hygiene (NonEmptyString/nes) and log actor rules (no actor on non-dialogue logs). Key takeaways:

All branded string fields require nes(...) for runtime/type safety.

Only dialogue logs may have an actor; all others must not.

Test data must use canonical helpers and match type requirements.

All repo-wide type/log changes must use codemods, with scripts and docs in /codemods/.

CI and pre-commit hooks enforce lint/type/test/doc sync; never merge with errors.

Documentation and ALL_FILES_INDEX.md must be updated in every batch.

For full details, see docs/error-reports/Error Report - July 10th 2025.md.

File: docs/DOCUMENTATION_POLICY.md
Documentation Policy & Automation

This document details the policies and automated processes for creating and maintaining accurate, up-to-date system documentation.

Document Conventions

Headings: All major sections use ##, subsections use ###.

Code/Commands: Use markdown code blocks for all commands and code snippets.

Terminology: See the Glossary of Terms for all domain-specific and architectural terms.

Documentation: Policy & Automation
Documentation Update Policy (Critical)

Best Practice & Policy: Whenever a file's implementation, responsibility, or integration changes (including refactors, logging, or SRP updates), the corresponding file description, tags, and criticality in project documentation MUST be updated in the same batch. This ensures the documentation always reflects the true state of the codebase and prevents architectural drift.

Automation & Self-Updating Architecture

Structured Comments: Critical files should contain structured comments:

Generated typescript
// @docs
// @description: The heart of the battle engine...
// @criticality: 🩸 High Risk
// @owner: AustroMelee
// @tags: core-logic, turn
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
TypeScript
IGNORE_WHEN_COPYING_END

Refresh Script: A script (npm run docs:refresh) scans the codebase for @docs tags and automatically regenerates tables and file indexes.

Code-Level Cross-Referencing: The script also parses imports/exports to generate "Used By" and "Calls" lists, providing a live map of dependencies.

Result: Zero drift between code and documentation and frictionless, accurate updates.

Legendary File Index Automation (ALL_FILES_INDEX.md)

Canonical File Map: docs/ALL_FILES_INDEX.md is the single source of truth for all files in the codebase. It is always up-to-date, generated by automation, and must never be hand-edited.

Automation Script: The file is generated by scripts/auto-crossref.cjs (run via node scripts/auto-crossref.cjs or as part of npm run docs:refresh).

Columns: The script generates a comprehensive table with columns for Path, Description, Category, Tags, Status, Last Modified, and Owner.

Orphaned/Dead Code Detection: The script analyzes the import graph to flag files not imported anywhere.

CI/Pre-commit Enforcement: The index must be updated in every commit that adds, removes, or modifies files. This is enforced by pre-commit/CI hooks.

Reference: For the full, always-up-to-date file listing, see docs/ALL_FILES_INDEX.md. For script details, see scripts/auto-crossref.cjs.

File: docs/LOGGING_SYSTEM.md
The Logging System

This document provides a detailed breakdown of the logging system's architecture, types, and usage rules. All developers working on features that produce battle output must adhere to these standards.

Log Type System (2025 Update)
LogEntryType

All log entries now have an explicit type field:

dialogue — In-character speech, taunts, or dialogue. Use logDialogue.

mechanics — Technical/mechanical outcomes, system events, or developer logs. Use logTechnical.

narrative — Pure narrative, story-driven lines, or scene-setting. Use logStory.

system — System-level messages, out-of-band notifications. Use logSystem.

Log Creation Rules

Always use the correct log generator for the intent:

Character speech: logDialogue({ ... })

Mechanics/results: logTechnical({ ... })

Narrative/story: logStory({ ... })

System message: logSystem({ ... })

Never create a log entry without a type.

When loading legacy logs, use the inferLogType(log) helper to assign a type if missing.

Visual Distinction in UI

Dialogue: Speech bubble, quotes, speaker face, 💬 icon

Mechanics: Gear/sword icon, flat box, ⚙️ icon

Narrative: Italic, “storybook” style, NarrativeBubble

System: Subtle, out-of-band message, 🖥️ icon

Example
Generated ts
logDialogue({ turn, actor: 'Azula', text: 'You cannot win, Avatar!' });
logTechnical({ turn, actor: 'System', action: 'Chi Drain', result: 'Azula loses 10 chi.' });
logStory({ turn, actor: 'Narrator', narrative: 'The arena trembles as the battle intensifies.' });
logSystem({ turn, actor: 'System', message: 'Battle paused for player input.' });
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Ts
IGNORE_WHEN_COPYING_END

All log types are enforced by TypeScript and reviewed in code review.

See src/features/battle-simulation/services/utils/mechanicLogUtils.ts for implementation.

Log View Modes: The UI supports multiple log view modes (see the UI Guide), with clear separation between developer and public-facing options.

File: CHANGELOG.md
Changelog

All notable changes to this project will be documented in this file.

[Unreleased]
Phase 5: Log Pipeline & UI Hardening (July 2025)

Log pipeline and UI are now robust, type-safe, and future-proof.

Renderer: UnifiedBattleLog.tsx uses an exhaustive switch for log types, with unknown types rendered as neutral gray.

Unit Test: UnifiedBattleLog.test.tsx covers all log types and ensures exhaustive rendering.

Lint Rule: Custom ESLint plugin prevents stray imports of DialogueLogEntry.

Type Helper: assertNever enforces compile-time exhaustiveness.

Log Creation: All logs are created via robust helpers (logTechnical, logStory, logDialogue, logSystem), never null, and strictly typed. All tactical subtypes are mapped to canonical types at the source. Duplicate log entries are prevented with a hash/set utility.

Phase 4: Escalation/Desperation/AI/Phase Logic Refactor (July 2025)

All escalation and desperation mechanics are now strictly phase-based, with no legacy flag checks.

AI move selection is contract-bound and phase-driven, with strict move pool enforcement in escalation/desperation.

All log creation and handling is robust, type-safe, and never null.

All escalation/desperation/AI/phase files are now fully type-safe and future-proof.

Batch cleanup of all type/lint errors and unused variables/imports.

Node.js scripts and documentation automation are robust and error-free.

Phase 3: Plug-and-Play Refactor Completion (July 2025)

All moves, AI rules, and narrative pools are now loaded via registries.

Adding new content is now a pure data/registry operation, fully decoupling the engine from content.

Phase 2.2: AAA Narrative Logging & SRP Finalization (July 2025)

All logs are now created via logStory or logTechnical utilities.

logStory now centralizes all narrative log hygiene: anti-repetition, null filtering, capitalization, and generic fallbacks.

Engine-level forced ending: A forcedEnding flag is set if both fighters reach maximum escalation, guaranteeing no infinite loops.

.cursorcontext compliance: Pre-commit and CI hooks enforce type, lint, and doc sync.

Phase 2.1: Critical Stability Update - Log Separation (July 2025)

Log Separation Enforced: Battle log entries are now strictly separated into NARRATIVE and INFO types.

Engine Refactor: All services now return log entries to be appended only in processTurn, enforcing a pure, one-way data flow.

File: GLOSSARY.md
Glossary of Terms

ADR: Architecture Decision Record. A document that captures a significant architectural decision along with its context and consequences.

Registry: A central service that loads and provides access to data-driven content (e.g., moves, AI rules, character data). This is key to the plug-and-play architecture.

SRP: Single Responsibility Principle. A core design principle stating that every module, class, or function should have responsibility over a single part of the functionality provided by the software.

(This section can be expanded as new terminology is introduced.)

File: docs/adr/0002-log-type-system.md
ADR 0002: Adopt a Discriminated Union for the Log Type System

Status: Accepted

Date: 2025-07-08

Deciders: Architecture Team

Context and Problem Statement

The previous logging system used two broad types, NARRATIVE and INFO, which was insufficient. We lacked a clear distinction between in-character dialogue, story-beat narration, and mechanical system events. This led to inconsistent UI rendering and made it difficult to filter logs for different audiences (players vs. developers).

Decision

We will refactor the BattleLogEntry type to be a discriminated union based on a type property. The new types will be: dialogue, narrative, mechanics, and system. Each type will have a strictly defined schema, enforced by TypeScript. For example, only the dialogue type will be allowed to have an actor property representing a fighter.

Consequences

Positive:

Greatly improved type safety.

Enables exhaustive checking in switches, preventing unhandled log types.

Allows for distinct and appropriate UI rendering for each log type.

Simplifies filtering for different log views (e.g., a "Story Only" view).

Negative:

Requires a significant, one-time refactor of all code that creates or consumes log entries.

Requires new, specialized helper functions (logDialogue, logStory, etc.) to ensure correct type creation.

File: docs/error-reports/Error Report - July 10th 2025.md
Post-Mortem: Branded String & Log Actor Enforcement

Date: 2025-07-10

Author: Lead Architect

Status: Resolved

1. Summary

A series of production and CI failures occurred due to inconsistent data shapes being passed to the logging pipeline. Specifically, null or empty strings were being assigned to fields typed as string, and the actor field was being incorrectly added to non-dialogue log entries. This caused runtime errors in the UI and failed assertions in our CI pipeline tests.

2. Root Cause Analysis

The root cause was twofold:

Type-level insufficiency: Standard string types do not prevent empty strings ('').

Schema drift: Developers were adding the actor property to mechanics logs for debugging, which violated the implicit schema and broke UI components expecting actor to only exist on dialogue.

3. Resolution and Recovery

Branded Types: Introduced NonEmptyString and a nes() utility to guarantee at both compile-time and run-time that a string is not empty.

Discriminated Union Enforcement: Modified the ESLint rules and TypeScript types to explicitly forbid the actor property on any log type other than dialogue.

Codemod Refactor: A jscodeshift codemod was written and executed across the entire repository to update all instances of log creation to use the new type-safe helpers and branded strings.

CI Hardening: The "canary" simulation test in CI was updated to assert these new, stricter log schemas.

4. Lessons Learned & Action Items

Type safety is not just about any; it's about semantic correctness.

All major, repo-wide refactors must be performed with codemods to ensure consistency.

CI must validate not just functionality, but data contracts.

All policies derived from this incident are now codified in docs/POLICIES.md.