AI-Agentic Cursor & SRP Guide

1. AI-Agentic Cursor Context

A codebase optimized for LLMs, with strict separation of concerns, zero-conflict architecture, and autonomous self-healing logic.

1A. Environment

Shell: powershell.exe on Win32 (Windows path style)

normalizePaths: true

1B. Proactive Autonomy

Self-Diagnose & Fix: On any error or misconfiguration, Cursor must:

Detect root cause

Apply the fix automatically

Explain the change and its intent

Re-run linters, type-checkers, and tests to validate fix

Iterate until resolved or externally blocked

No User Delegation: Never ask the user to troubleshoot.

1C. General Principles

Scan First: Always read relevant code before asking questions.

Code for AI: Prioritize clarity, redundancy, and explicit structure.

No Dev Server: Never run unless explicitly requested.

1D. File Structure Rules

Max File Size: ≤500 lines or 6K characters

One Responsibility: Each file implements a single domain concept.

Domain Folders Only: Organize by feature/domain (e.g., features/auth/components/LoginForm.tsx) not flat categories.

1E. TypeScript Practices

Use type over interface unless extending libraries.

Name all types explicitly and uniquely (e.g., ButtonProps, TalentNode).

Keep types simple—avoid deeply nested generics.

Never redefine or shadow type names.

1F. Function Design

Use VerbNoun names (e.g., loadUser, fetchReport).

Max 3–4 parameters: prefer object destructuring.

Explicit return types with named shapes.

Pure by default. Side effects require clear names (e.g., logAndSend).

1G. Naming & Semantics

No single-letter variables or vague names.

Extract magic values into named constants.

1H. Comments & Docblocks

All exports must have doc comments.

Annotate complex logic with intent-driven inline comments.

1I. Modules & Dependency Rules

No Circular Imports.

Explicit Imports Only: No star or side-effect imports.

Layering Rule: High-level modules may not import from lower-level ones.

Use Dependency Cruiser to verify module boundaries.

1J. Error Handling

No empty catch blocks.

All errors must be contextual and actionable.

1K. LLM Editability Guarantees

Break complex logic into named subfunctions.

Tag unstable code with // FIXME: or // TEMP:.

Never hide logic in nested closures.

1L. Main Contextual Pillars (MCPs) & Context7 Limits

Limit to 7 logical domains per session.

Use inline tags: // CONTEXT: Auth, // FOCUS: TokenValidation

1M. Sequential Prompt Flow

@plan → outline steps

@explain → describe behavior

@rewrite → apply refactor

2. Single Responsibility Principle (SRP)

Each file/module must have one reason to change.

2A. Core Module Types

features/ – feature modules (auth, user-profile, etc.)

common/ – shared hooks/components/utils

tests/ – all unit/integration tests

2B. Folder Structure Example

src/
├── features/
│   ├── authentication/
│   │   ├── prompts/
│   │   ├── validation/
│   │   ├── services.ts
│   │   ├── controller.ts
│   │   └── components/
│   │       ├── LoginForm.tsx
│   │       └── LoginForm.module.css
│   └── user-profile/
├── common/
│   ├── components/
│   └── hooks/
└── tests/

2C. SRP Checklist

One-sentence responsibility

No unrelated imports

File name matches role

Testable with mocks/stubs

2D. Refactor Rules

Preserve existing behavior

Extract, don’t reinvent

Small, atomic commits

Separate feature, fix, and refactor changes

3. Operational Practices

3.1 Prompt Versioning

Metadata tags: version, author, summary

Maintain changelogs alongside templates

3.2 Metrics & Cost Tracking

Log token usage, latency, and errors

Add cost alerts/dashboards

3.3 Security & Privacy

Redact PII in all inputs/outputs

Run sanitizer before every LLM call

Ban unsafe or unmaintained SDKs

3.4 CI/CD

Lint & format prompts

Stub LLM calls for contract testing

Full pipeline from prompt → UI

3.5 Collaboration

All prompt/parser changes via PR with peer review

Use docs(prompt): commit style

3.6 Observability

Centralize model errors & logs

Track parse error rates & latencies

3.7 Testing

Golden-prompt integration tests

JSON Schema validation for parsed outputs

4. UI, CSS, and Conflict Prevention

4.1 Style Application Conflicts

Never reuse class names across modules

Use CSS Modules only

All classes must be locally scoped and imported as named bindings

Avoid generic classes like .tooltip; use .talent-tooltip

Confirm CSS variable availability at build time

4.2 Load Order & Source Conflicts

If using HTML <link> tags without a bundler:

<link rel="stylesheet" href="/styles/variables.css">
<link rel="stylesheet" href="/styles/grid.css">
<link rel="stylesheet" href="/styles/nodes.css">
<link rel="stylesheet" href="/styles/tooltip.css">

Otherwise, prefer JS-based import statements handled by bundlers (Vite, Webpack)

Never mix <link> and import styles in the same project unless explicitly separated

4.3 Visual Pathfinding (for Connectors)

All visual edge logic must use real graph data, even if progression filters apply elsewhere

Don’t exclude nodes from visual traversals unless connections are direct

Validate all connector renders after progression rule changes

4.4 CSS Debugging Practices

Match class names to component names exactly

Use DevTools to inspect active rules and specificity

Centralize all colors/spacings in variables.css

Use stylelint in CI to catch typos, duplicates

4.5 Overflow & Scrolling (Critical)

Never apply overflow: hidden to a parent of a scrollable UI

Use overflow-x: auto

Audit overflow clipping when horizontal scroll breaks

5. Feature Integration Protocol (Cursor-Specific)

5.1 Cursor Must:

Log all modified files

Detect type, style, and dependency conflicts before writing

Never modify >3 files per request unless explicitly authorized

5.2 When implementing external LLM snippets:

Translate snippet to existing folder structure

Refactor imports, types, and styles to avoid shadowing

Stop and warn if any rule above is in conflict

5.3 Dependency Checks (Mandatory)

All CSS variable usages must resolve

All TypeScript type names must be globally unique

All public types/interfaces must be colocated or namespaced

Use Dependency Cruiser for every major change

This Cursor context governs all behavior across the AI-assisted workflow. Any violation, conflict, or ambiguity must trigger a halt and explain sequence. Cursor is expected to act with architectural awareness and full policy compliance at all times.

